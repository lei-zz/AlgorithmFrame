> 回溯算法本质是DFS（深度优先） 算法，本质上就是一种暴力穷举算法
>

# 解决什么问题

**一个决策树的遍历过程** 

# 框架

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
  
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

# 全排列问题

<iframe src="https://leetcode-cn.com/problems/permutations/" data-src="" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="height: 530px;"></iframe>

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。 **我们不妨把这棵树称为回溯算法的「决策树」** 。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策** 。

**`[2]` 就是「路径」，记录你已经做过的选择；**

**`[1,3]` 就是「选择列表」，表示你当前可以做出的选择；**

**「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候** 。​
